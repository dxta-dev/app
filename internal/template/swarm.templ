package template

import (
	"github.com/dxta-dev/app/internal/data"

	"time"
)

type SwarmProps struct {
	Series                 SwarmSeries
	StartOfTheWeek         time.Time
	EventIds               []int64
	EventMergeRequestIds   []int64
	StartedMergeRequestIds []int64
	ClosedMergeRequestIds  []int64
}

var eventTypeNames = map[data.EventType]string{
	data.UNKNOWN:                "UNKNOWN",
	data.OPENED:                 "OPENED",
	data.STARTED_CODING:         "STARTED_CODING",
	data.STARTED_PICKUP:         "STARTED_PICKUP",
	data.STARTED_REVIEW:         "STARTED_REVIEW",
	data.NOTED:                  "NOTED",
	data.ASSIGNED:               "ASSIGNED",
	data.CLOSED:                 "CLOSED",
	data.COMMENTED:              "COMMENTED",
	data.COMMITTED:              "COMMITTED",
	data.CONVERT_TO_DRAFT:       "CONVERT_TO_DRAFT",
	data.MERGED:                 "MERGED",
	data.READY_FOR_REVIEW:       "READY_FOR_REVIEW",
	data.REVIEW_REQUEST_REMOVED: "REVIEW_REQUEST_REMOVED",
	data.REVIEW_REQUESTED:       "REVIEW_REQUESTED",
	data.REVIEWED:               "REVIEWED",
	data.UNASSIGNED:             "UNASSIGNED",
}

func getEventName(eventType data.EventType) string {
	if name, exists := eventTypeNames[eventType]; exists {
		return name
	}
	return "Invalid EventType"
}

type ActorInfo struct {
	AvatarUrl string
	Name      string
}

func uniqueActorInfo(input []data.Event) []ActorInfo {
	uniqueMap := make(map[string]ActorInfo)
	var uniqueSlice []ActorInfo

	for _, event := range input {
		if _, ok := uniqueMap[event.Actor.AvatarUrl]; !ok {
			uniqueMap[event.Actor.AvatarUrl] = ActorInfo{
				AvatarUrl: event.Actor.AvatarUrl,
				Name:      event.Actor.Name,
			}
			uniqueSlice = append(uniqueSlice, uniqueMap[event.Actor.AvatarUrl])
		}
	}

	return uniqueSlice
}

script getChart(chartId string, endpoint string, circleIds []int64, circleMergeRequestIds []int64, startedMergeRequestIds []int64, closedMergeRequestIds []int64) {

	if (circleIds === null) {
		return;
	}

	const svg = document.querySelector(`${chartId} > svg`);
    const circles = document.querySelectorAll(`${chartId} > svg > circle`);

	function createFilter() {
		const filter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
		filter.setAttribute("id", "swarm-blur");

		const feGaussianBlur = document.createElementNS("http://www.w3.org/2000/svg", "feGaussianBlur");
		feGaussianBlur.setAttribute("in", "SourceGraphic");
		feGaussianBlur.setAttribute("stdDeviation", "1");

		filter.appendChild(feGaussianBlur);
		svg.appendChild(filter);
	}

	createFilter();



	function toggleBlur(elements) {
		elements.forEach((element) => {
			if (element.getAttribute("filter") === "url(#swarm-blur)") {
				element.removeAttribute("filter");
			} else {
				element.setAttribute("filter", "url(#swarm-blur)");
			}
		});
	}

	function moveToTop(element) {
		element.parentNode.appendChild(element);
	}

	function getCircleInfo(mrid) {
		const searchParams = new URLSearchParams(document.location.search);
		searchParams.set('mr', mrid);
		const endpointWithMrid = `${endpoint}${mrid}`;
		const mrUrl = new URL(endpointWithMrid, document.location.origin);
		htmx.ajax('GET', mrUrl.toString(), '#mr-info');

	}

	const lineAtrs = [
		["stroke", "blue"],
		["stroke-width", "2"],
	]

	const dashedLineAtrs = [
		...lineAtrs,
		["stroke-dasharray", "6"],
	]

	function createLine(x1, y1, x2, y2, atrs) {
		const line = document.createElementNS("http://www.w3.org/2000/svg", "line");

		line.setAttribute("x1", x1);
		line.setAttribute("y1", y1);
		line.setAttribute("x2", x2);
		line.setAttribute("y2", y2);

		atrs.forEach(([key, value]) => {
			line.setAttribute(key, value);
		});

		return line;

	}

	function createLineBetweenCircles(x1, y1, x2, y2) {
		return createLine(x1, y1, x2, y2, lineAtrs);
	}

	function calculateDistance(x1, y1, x2, y2) {
		return Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2);
	}

	function orderCircles(circles) {
		if (circles.length === 0) return [];
		if (circles.length === 1) return circles;
		return Array.from(circles).sort((a, b) => {
			const x = Number(a.getAttribute("cx")) - Number(b.getAttribute("cx"));
			const y = Number(a.getAttribute("cy")) - Number(b.getAttribute("cy"));
			if (x !== 0) return x;
			return y;
		})
	}

	const searchParams = new URLSearchParams(document.location.search);

	for (let i = 0; i < circles.length; i++) {
		circles[i].setAttribute("data-id", circleIds[i]);
		circles[i].setAttribute("data-merge-request-id", circleMergeRequestIds[i]);
	}

	let size = +circles[0].getAttribute("r");

	let highlightedButton = null;

	circles.forEach((circle, i) => {
		let strokes = [];
		let lines = [];
		circle.addEventListener("mouseover", () => {
			const mergeRequestId = circle.getAttribute("data-merge-request-id");
			const button = document.querySelector(`button[hx-get="/mr-info/${mergeRequestId}"]`);

			if (button) {
				const grandparentElement = button.parentElement.parentElement;

				if (highlightedButton && highlightedButton !== grandparentElement) {
					highlightedButton.classList.remove('border-2', 'border-blue-500');
				}

				grandparentElement.classList.add('border-2', 'border-blue-500');
				highlightedButton = grandparentElement;

				const rect = grandparentElement.getBoundingClientRect();
				const offset = 340; // Magic number
				const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
				const top = rect.top + scrollTop - offset;

				window.scrollTo({ top: top, behavior: 'smooth' });

			}


			let circles = document.querySelectorAll(`${chartId} > svg > circle[data-merge-request-id="${mergeRequestId}"]`);

			const otherCircles = document.querySelectorAll(`${chartId} > svg > circle:not([data-merge-request-id="${mergeRequestId}"])`);

			toggleBlur(otherCircles);

			circles = orderCircles(circles);
			prevCircle = circles[0];
			lastCircle = circles[circles.length - 1];

			if (!startedMergeRequestIds.includes(Number(mergeRequestId))) {
				const line = createLine(
					prevCircle.getAttribute("cx"), prevCircle.getAttribute("cy"),
					0, 195/2,
					dashedLineAtrs
				);
				lines.push(line);
				svg.appendChild(line);
			}
			if (!closedMergeRequestIds.includes(Number(mergeRequestId))) {
				const line = createLine(
					lastCircle.getAttribute("cx"), lastCircle.getAttribute("cy"),
					1405, 195/2,
					dashedLineAtrs
				);
				lines.push(line);
				svg.appendChild(line);
			}

			for (let i = 0; i < circles.length; i++) {
				circles[i].setAttribute("r", size + 2);
				strokes.push(circles[i].style.stroke);
				circles[i].style.stroke = "blue";
				circles[i].style.strokeWidth = "2";
				if (i > 0 && 300 < calculateDistance(prevCircle.getAttribute("cx"), prevCircle.getAttribute("cy"), circles[i].getAttribute("cx"), circles[i].getAttribute("cy"))){
					const line = createLineBetweenCircles(prevCircle.getAttribute("cx"), prevCircle.getAttribute("cy"), circles[i].getAttribute("cx"), circles[i].getAttribute("cy"));
					lines.push(line);
					svg.appendChild(line);
				}
				prevCircle = circles[i];
			}
			for (let i = 0; i < circles.length; i++) {
				moveToTop(circles[i]);
			}
		});

		circle.addEventListener("mouseout", () => {
			const mergeRequestId = circle.getAttribute("data-merge-request-id");
			const circles = document.querySelectorAll(`${chartId} > svg > circle[data-merge-request-id="${mergeRequestId}"]`);

			const otherCircles = document.querySelectorAll(`${chartId} > svg > circle:not([data-merge-request-id="${mergeRequestId}"])`);
			toggleBlur(otherCircles);

			for (let i = 0; i < circles.length; i++) {
				circles[i].setAttribute("r", size);
				circles[i].style.stroke = strokes[i];
				circles[i].style.strokeWidth = "1";
			}
			for (let i = 0; i < lines.length; i++) {
				lines[i].remove();
			}
			strokes = [];
			lines = [];

			if (highlightedButton) {
                highlightedButton.classList.remove('border-2', 'border-blue-500');
                highlightedButton = null;
            }

            window.scrollTo({ top: 0, behavior: 'smooth' });
		});


		circle.addEventListener("click", () => {
			const popover = document.getElementById("mr-info");
			popover.showPopover();
			getCircleInfo(Number(circle.getAttribute("data-merge-request-id")));
		});

	});



}

templ swarm(props SwarmProps, nonce string) {
	<div class="pl-[10px] pr-[15px] pb-2" id="swarm-chart">
		<style nonce={ nonce } text="text/css">
			svg > circle:hover {
				cursor: pointer;
			}
		</style>
		@swarmChartComponent(props.Series, props.StartOfTheWeek)
		@getChart("#swarm-chart", "mr-info/", props.EventIds, props.EventMergeRequestIds, props.StartedMergeRequestIds, props.ClosedMergeRequestIds)
	</div>
}
